<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Scan Muka — Debug Liveness (Complete)</title>
<style>
  :root{--bg:#071426;--card:#0b1220;--accent:#06b6d4;--text:#e6eef6}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;color:var(--text);background:linear-gradient(180deg,#041024,#071428);display:flex;align-items:flex-start;justify-content:center;padding:18px}
  .frame{width:980px;max-width:98%;background:rgba(255,255,255,0.02);padding:16px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  h1{margin:0 0 10px 0;font-size:18px}
  .layout{display:flex;gap:14px;flex-wrap:wrap}
  .left{flex:1;min-width:320px}
  .right{width:360px}
  .video-wrap{position:relative;background:#000;border-radius:8px;overflow:hidden}
  video{width:100%;height:auto;display:block}
  canvas{position:absolute;left:0;top:0;pointer-events:none}
  .instr{background:#061423;padding:10px;border-radius:8px;margin-top:10px;font-size:14px}
  .controls{margin-top:10px}
  button{background:var(--accent);color:#022;padding:10px 14px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
  .small{font-size:13px;color:#9fb5c1;margin-top:6px}
  .debug{background:#061322;padding:10px;border-radius:8px;margin-top:10px;font-size:13px;line-height:1.4}
  .ok{color:#7ef0b6;font-weight:700}
  .warn{color:#ffd36b;font-weight:700}
  .err{color:#ff8b8b;font-weight:700}
  .media-list{margin-top:8px;max-height:220px;overflow:auto}
  a{color:var(--accent)}
</style>

<!-- Load TFJS UMD first -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>

<!-- Load face-landmarks-detection ESM and expose to window -->
<script type="module">
  try {
    const mod = await import('https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@1.0.3/dist/face-landmarks-detection.esm.js');
    window.faceLandmarksDetection = mod;
    console.log('faceLandmarksDetection (ESM) loaded');
  } catch (err) {
    console.error('Failed to load face-landmarks-detection ESM:', err);
    // keep window.faceLandmarksDetection undefined; main script will handle this.
  }
</script>
</head>
<body>
  <div class="frame">
    <h1>Scan Muka — Debug Liveness</h1>
    <div class="layout">
      <div class="left">
        <div class="video-wrap">
          <video id="video" autoplay playsinline muted></video>
          <canvas id="overlay"></canvas>
        </div>

        <div class="instr" id="mainInstruction">Instruksi: Tekan <strong>Mulai Scan</strong></div>

        <div class="controls">
          <button id="startBtn">Mulai Scan</button>
          <button id="stopBtn" style="display:none">Stop</button>
          <button id="chooseFolderBtn">Pilih Folder Simpan (opsional)</button>
        </div>

        <div class="small" id="statusLine">Status: idle</div>
      </div>

      <aside class="right">
        <div class="debug">
          <div><strong>Model status:</strong> <span id="modelStatus" class="warn">loading...</span></div>
          <div><strong>Face detected:</strong> <span id="faceDetected" class="err">no</span></div>
          <div><strong>Step:</strong> <span id="stepLabel">-</span> (<span id="progress">0/5</span>)</div>
          <hr style="border:none;border-top:1px solid rgba(255,255,255,0.04);margin:8px 0">
          <div><strong>yaw</strong>: <span id="valYaw">-</span></div>
          <div><strong>pitch</strong>: <span id="valPitch">-</span></div>
          <div><strong>EAR</strong>: <span id="valEAR">-</span></div>
          <div><strong>blinkNow</strong>: <span id="valBlink">-</span></div>
          <div><strong>motion</strong>: <span id="valMotion">-</span></div>
          <hr style="border:none;border-top:1px solid rgba(255,255,255,0.04);margin:8px 0">
          <div id="messages" class="small">Messages appear here.</div>
        </div>

        <div class="instr" style="margin-top:10px">
          <strong>Media (preview)</strong>
          <div class="media-list" id="mediaList"></div>
        </div>
      </aside>
    </div>
  </div>

<script>
/* --- CONFIG --- */
const MAX_TIME = 120;
const FPS_CAPTURE_MS = 1000;
const EAR_BLINK_THRESHOLD = 0.18;
const CONSECUTIVE_REQUIRED = 3;
const BLINK_COOLDOWN_MS = 400;

/* --- DOM --- */
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const chooseFolderBtn = document.getElementById('chooseFolderBtn');
const modelStatus = document.getElementById('modelStatus');
const faceDetectedEl = document.getElementById('faceDetected');
const stepLabel = document.getElementById('stepLabel');
const progressEl = document.getElementById('progress');
const valYaw = document.getElementById('valYaw');
const valPitch = document.getElementById('valPitch');
const valEAR = document.getElementById('valEAR');
const valBlink = document.getElementById('valBlink');
const valMotion = document.getElementById('valMotion');
const messages = document.getElementById('messages');
const mainInstruction = document.getElementById('mainInstruction');
const mediaList = document.getElementById('mediaList');
const statusLine = document.getElementById('statusLine');

let model = null;
let streamRef = null;
let recorder = null;
let recordedBlobs = [];
let frameBlobs = [];
let captureInterval = null;
let lastFrameData = null;
let folderHandle = null;

/* --- load model safely (wait for ESM exposure) --- */
async function loadModelWithRetry(){
  modelStatus.textContent = 'loading...';
  // wait a bit for window.faceLandmarksDetection (ESM loader above)
  for(let i=0;i<15 && !window.faceLandmarksDetection;i++){
    await new Promise(r=>setTimeout(r,200));
  }
  if(!window.faceLandmarksDetection){
    modelStatus.textContent = 'failed';
    modelStatus.className = 'err';
    messages.textContent = 'faceLandmarksDetection tidak tersedia. Periksa koneksi CDN atau urutan skrip.';
    return;
  }
  try{
    // prefer webgl backend if possible
    if(window.tf && window.tf.setBackend){
      try{ await window.tf.setBackend('webgl'); }catch(e){ /* ignore */ }
    }
    const fld = window.faceLandmarksDetection;
    model = await fld.load(fld.SupportedPackages.mediapipeFacemesh, {maxFaces:1});
    modelStatus.textContent = 'ready';
    modelStatus.className = 'ok';
    messages.textContent = 'Model siap. Tekan Mulai Scan.';
  } catch(err){
    console.error('model load error', err);
    modelStatus.textContent = 'failed';
    modelStatus.className = 'err';
    messages.textContent = 'Gagal memuat model: ' + (err.message || String(err));
  }
}
loadModelWithRetry();

/* --- helpers --- */
function addMediaItem(name, blob){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = name; a.textContent = name;
  mediaList.prepend(a);
}
function clearCanvas(){ ctx.clearRect(0,0,overlay.width,overlay.height); }
function averagePoint(idxs, landmarks){
  let x=0,y=0,c=0;
  for(const i of idxs){ if(!landmarks[i]) continue; x+=landmarks[i][0]; y+=landmarks[i][1]; c++; }
  return [x/c, y/c];
}
function computeEAR(upper, lower){
  const v = (Math.hypot(upper[1][0]-lower[5][0], upper[1][1]-lower[5][1]) +
             Math.hypot(upper[2][0]-lower[4][0], upper[2][1]-lower[4][1]))/2;
  const h = Math.hypot(upper[0][0]-upper[3][0], upper[0][1]-upper[3][1]) || 1;
  return v/h;
}
function estimateYaw(landmarks){
  const left = averagePoint([33,133,159,158], landmarks);
  const right = averagePoint([362,263,386,387], landmarks);
  const nose = landmarks[1] || [(left[0]+right[0])/2,(left[1]+right[1])/2];
  const dxL = nose[0] - left[0];
  const dxR = right[0] - nose[0];
  return (dxL - dxR) * 0.5;
}
function estimatePitch(landmarks){
  const nose = landmarks[1] || [0,0];
  const eyeCenter = averagePoint([33,133,362,263], landmarks);
  return (eyeCenter[1] - nose[1]);
}
function computeFrameDiff(imgData){
  if(!lastFrameData){ lastFrameData = imgData; return 0; }
  let diff=0;
  for(let i=0;i<imgData.data.length;i+=4){
    diff += Math.abs(imgData.data[i]-lastFrameData.data[i]);
    diff += Math.abs(imgData.data[i+1]-lastFrameData.data[i+1]);
    diff += Math.abs(imgData.data[i+2]-lastFrameData.data[i+2]);
  }
  lastFrameData = imgData;
  return diff / (imgData.data.length/4);
}

/* --- folder picker --- */
chooseFolderBtn.addEventListener('click', async ()=>{
  if('showDirectoryPicker' in window){
    try{
      folderHandle = await window.showDirectoryPicker();
      messages.textContent = 'Folder terpilih: Anda dapat menyimpan hasil ke folder ini.';
    }catch(e){
      messages.textContent = 'Pemilihan folder dibatalkan.';
    }
  } else {
    messages.textContent = 'Browser tidak mendukung penyimpanan lokal otomatis. ZIP fallback akan digunakan.';
  }
});

/* --- camera start --- */
async function startCamera(){
  const s = await navigator.mediaDevices.getUserMedia({video:{width:640,height:480,facingMode:'user'}, audio:true});
  video.srcObject = s;
  streamRef = s;
  await video.play();
  overlay.width = video.videoWidth || 640;
  overlay.height = video.videoHeight || 480;
  return s;
}

/* --- STEPS machine --- */
const STEPS = [
  { id:'center', label:'Hadapkan muka ke tengah', validator: c=> Math.abs(c.avgYaw) < 8 && Math.abs(c.avgPitch) < 10, need: CONSECUTIVE_REQUIRED },
  { id:'left', label:'Miring ke KIRI', validator: c=> c.avgYaw < -12, need: CONSECUTIVE_REQUIRED },
  { id:'right', label:'Miring ke KANAN', validator: c=> c.avgYaw > 12, need: CONSECUTIVE_REQUIRED },
  { id:'blink', label:'Kedipkan mata', validator: c=> c.blinkNow === true, need: 1 },
  { id:'nod', label:'Angguk kepala', validator: c=> Math.abs(c.avgPitch) > 12, need: CONSECUTIVE_REQUIRED }
];
let current = 0;
let yawBuf = [], pitchBuf = [], earBuf = [], lastBlinkTs = 0, consecutive = {};

/* --- start button handler --- */
startBtn.addEventListener('click', async ()=>{
  startBtn.style.display = 'none';
  stopBtn.style.display = 'inline-block';
  statusLine.textContent = 'Memulai...';
  mainInstruction.textContent = 'Izinkan kamera jika diminta.';
  messages.textContent = '';

  try{ await startCamera(); } catch(err){
    messages.textContent = 'Gagal akses kamera: ' + (err.message || err);
    startBtn.style.display = 'inline-block'; stopBtn.style.display = 'none';
    return;
  }

  // recorder + frame capture
  recordedBlobs = []; frameBlobs = []; lastFrameData = null;
  try{ recorder = new MediaRecorder(streamRef, {mimeType:'video/webm;codecs=vp9,opus'}); }catch(e){ recorder = new MediaRecorder(streamRef); }
  recorder.ondataavailable = e=>{ if(e.data && e.data.size) recordedBlobs.push(e.data); };
  recorder.start();
  const capCanvas = document.createElement('canvas'); capCanvas.width = overlay.width; capCanvas.height = overlay.height;
  const capCtx = capCanvas.getContext('2d');
  captureInterval = setInterval(()=>{
    capCtx.drawImage(video,0,0,capCanvas.width,capCanvas.height);
    capCanvas.toBlob(b=>{
      const ts = Date.now(); const name = `frame_${ts}.png`; frameBlobs.push({blob:b,name}); addMediaItem(name,b);
    }, 'image/png');
  }, FPS_CAPTURE_MS);

  // reset states
  current = 0; yawBuf=[]; pitchBuf=[]; earBuf=[]; lastBlinkTs=0; consecutive={};
  STEPS.forEach(s=>consecutive[s.id]=0);
  statusLine.textContent = 'Scanning...';
  mainInstruction.textContent = STEPS[current].label;
  stepLabel.textContent = STEPS[current].label;
  progressEl.textContent = `0/${STEPS.length}`;
  detectLoop();
});

/* --- detection loop --- */
let detectLoopActive = false;
async function detectLoop(){
  detectLoopActive = true;
  const startTime = Date.now();

  async function loop(){
    if(!detectLoopActive) return;
    if(!model){ messages.textContent = 'Model belum siap.'; requestAnimationFrame(loop); return; }
    const preds = await model.estimateFaces({input:video, returnTensors:false, flipHorizontal:true});
    clearCanvas();

    if(preds && preds.length>0){
      faceDetectedEl.textContent = 'yes'; faceDetectedEl.className = 'ok';
      const p = preds[0], lm = p.scaledMesh;
      // small landmarks draw
      ctx.fillStyle = 'rgba(6,182,212,0.9)';
      for(let i=0;i<lm.length;i+=10){ ctx.beginPath(); ctx.arc(lm[i][0], lm[i][1], 1.2,0,Math.PI*2); ctx.fill(); }

      // compute values
      const yaw = estimateYaw(lm); const pitch = estimatePitch(lm);
      yawBuf.push(yaw); if(yawBuf.length>5) yawBuf.shift();
      pitchBuf.push(pitch); if(pitchBuf.length>5) pitchBuf.shift();

      const leftUpper = [lm[159], lm[160], lm[158], lm[33]];
      const leftLower = [lm[145], lm[144], lm[153], lm[133]];
      const rightUpper = [lm[386], lm[387], lm[385], lm[362]];
      const rightLower = [lm[374], lm[373], lm[380], lm[263]];
      const earL = computeEAR(leftUpper,leftLower);
      const earR = computeEAR(rightUpper,rightLower);
      const ear = (earL+earR)/2;
      earBuf.push(ear); if(earBuf.length>8) earBuf.shift();

      // blink detection (dip then rise)
      let blinkNow = false;
      if(earBuf.length >= 3){
        const a = earBuf[earBuf.length-3], b = earBuf[earBuf.length-2], c = earBuf[earBuf.length-1];
        if(b < EAR_BLINK_THRESHOLD && c >= EAR_BLINK_THRESHOLD && (Date.now()-lastBlinkTs) > BLINK_COOLDOWN_MS){
          blinkNow = true; lastBlinkTs = Date.now();
        }
      }

      // motion
      const tmp = document.createElement('canvas'); tmp.width = overlay.width; tmp.height = overlay.height;
      const tctx = tmp.getContext('2d'); tctx.drawImage(video,0,0,tmp.width,tmp.height);
      const id = tctx.getImageData(0,0,tmp.width,tmp.height);
      const motion = computeFrameDiff(id);

      // context values and UI updates
      const avgYaw = yawBuf.reduce((a,b)=>a+b,0)/yawBuf.length;
      const avgPitch = pitchBuf.reduce((a,b)=>a+b,0)/pitchBuf.length;
      valYaw.textContent = avgYaw.toFixed(2);
      valPitch.textContent = avgPitch.toFixed(2);
      valEAR.textContent = ear.toFixed(3);
      valBlink.textContent = blinkNow ? 'yes' : 'no';
      valMotion.textContent = motion.toFixed(1);

      // step validation
      const step = STEPS[current];
      stepLabel.textContent = step.label;
      const ctxObj = { avgYaw, avgPitch, ear, earBuf, blinkNow, motion };
      const ok = step.validator(ctxObj);
      if(step.id !== 'blink'){
        if(ok) consecutive[step.id] = Math.min(step.need, consecutive[step.id] + 1);
        else consecutive[step.id] = 0;
        mainInstruction.textContent = `${step.label} (${consecutive[step.id]}/${step.need})`;
      } else {
        if(ok) consecutive[step.id] = 1;
        mainInstruction.textContent = `${step.label} (${consecutive[step.id]}/${step.need})`;
      }

      // advance when enough consecutive
      if(consecutive[step.id] >= step.need){
        mainInstruction.textContent = `${step.label} — OK`;
        current++;
        progressEl.textContent = `${current}/${STEPS.length}`;
        if(current < STEPS.length){
          stepLabel.textContent = STEPS[current].label;
          mainInstruction.textContent = `Berhasil: lanjut → ${STEPS[current].label}`;
          yawBuf=[]; pitchBuf=[]; earBuf=[];
          Object.keys(consecutive).forEach(k=>consecutive[k]=0);
          await new Promise(r=>setTimeout(r,500));
        } else {
          // final motion check
          if(motion > 8){
            detectLoopActive = false;
            await finish(true);
            return;
          } else {
            mainInstruction.textContent = 'Gerakkan kepala sedikit untuk verifikasi akhir';
            // wait briefly for motion
            await new Promise(r=>setTimeout(r,800));
            if(lastFrameData && computeFrameDiff(lastFrameData) > 8){
              detectLoopActive = false; await finish(true); return;
            } else { detectLoopActive = false; await finish(false); return; }
          }
        }
      }
    } else {
      faceDetectedEl.textContent = 'no'; faceDetectedEl.className = 'err';
      mainInstruction.textContent = STEPS[current].label;
      valYaw.textContent = '-'; valPitch.textContent='-'; valEAR.textContent='-'; valBlink.textContent='-'; valMotion.textContent='-';
    }

    // timeout
    const elapsed = Math.floor((Date.now() - startTime)/1000);
    if(elapsed >= MAX_TIME){
      detectLoopActive = false; await finish(false); return;
    }

    requestAnimationFrame(loop);
  }
  loop();
}

/* --- stop & cleanup --- */
stopBtn.addEventListener('click', ()=>cleanup(true));

function cleanup(showStart){
  detectLoopActive = false;
  clearInterval(captureInterval);
  if(recorder && recorder.state !== 'inactive') try{ recorder.stop(); }catch(e){}
  if(streamRef){ streamRef.getTracks().forEach(t=>t.stop()); streamRef=null; }
  if(showStart){ startBtn.style.display = 'inline-block'; stopBtn.style.display = 'none'; statusLine.textContent = 'Dihentikan.'; }
}

/* --- finish: save and redirect or retry --- */
async function finish(success){
  statusLine.textContent = success ? 'Verifikasi: BERHASIL' : 'Verifikasi: GAGAL';
  clearInterval(captureInterval);
  if(recorder && recorder.state !== 'inactive') try{ recorder.stop(); }catch(e){}
  if(streamRef){ streamRef.getTracks().forEach(t=>t.stop()); streamRef=null; }

  const videoBlob = new Blob(recordedBlobs, {type: recordedBlobs[0]?.type || 'video/webm'});
  addMediaItem(`scan_result_${Date.now()}.webm`, videoBlob);

  // create minimal manifest
  const manifest = { result: success ? 'success' : 'failed', ts: Date.now(), frames_count: frameBlobs.length, video_size: videoBlob.size };
  // try save to folder (frames subfolder) if available
  if(folderHandle && 'getDirectoryHandle' in folderHandle){
    try{
      const framesDir = await folderHandle.getDirectoryHandle('frames', {create:true});
      const vHandle = await folderHandle.getFileHandle(`scan_result_${manifest.ts}.webm`, {create:true});
      const wv = await vHandle.createWritable(); await wv.write(videoBlob); await wv.close();
      for(const f of frameBlobs){
        const fh = await framesDir.getFileHandle(f.name, {create:true});
        const wf = await fh.createWritable(); await wf.write(f.blob); await wf.close();
      }
      const mf = await folderHandle.getFileHandle(`manifest_${manifest.ts}.json`, {create:true});
      const wm = await mf.createWritable(); await wm.write(JSON.stringify(manifest,null,2)); await wm.close();
      messages.textContent = `Tersimpan ke folder lokal (${success ? 'success' : 'failed'}).`;
    }catch(e){
      console.error('Save error', e);
      messages.textContent = 'Gagal menyimpan ke folder; file tersedia di preview.';
    }
  } else {
    messages.textContent = 'Hasil tersedia di preview (folder tidak dipilih).';
  }

  if(success){
    setTimeout(()=>{ window.location.href = `result.html?result=success&ts=${manifest.ts}`; }, 700);
  } else {
    startBtn.style.display = 'inline-block'; stopBtn.style.display = 'none';
    messages.textContent = 'Verifikasi gagal — coba ulang.';
  }
}

/* cleanup on unload */
window.addEventListener('beforeunload', ()=>{ if(streamRef) streamRef.getTracks().forEach(t=>t.stop()); });
</script>
</body>
</html>