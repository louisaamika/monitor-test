<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Scan Muka — Fullset</title>
<style>
  :root{--bg:#071428;--card:#0b1220;--accent:#06b6d4;--text:#e6eef6}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;color:var(--text);background:linear-gradient(180deg,#041024,#071428);display:flex;align-items:flex-start;justify-content:center;padding:18px}
  .frame{width:980px;max-width:98%;background:rgba(255,255,255,0.02);padding:16px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  h1{margin:0 0 10px 0;font-size:18px}
  .layout{display:flex;gap:14px;flex-wrap:wrap}
  .left{flex:1;min-width:320px}
  .right{width:360px}
  .video-wrap{position:relative;background:#000;border-radius:8px;overflow:hidden}
  video{width:100%;height:auto;display:block}
  canvas{position:absolute;left:0;top:0;pointer-events:none}
  .instr{background:#061423;padding:10px;border-radius:8px;margin-top:10px;font-size:14px}
  .controls{margin-top:10px}
  button{background:var(--accent);color:#022;padding:10px 14px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
  .small{font-size:13px;color:#9fb5c1;margin-top:6px}
  .debug{background:#061322;padding:10px;border-radius:8px;margin-top:10px;font-size:13px;line-height:1.4}
  .media-list{margin-top:8px;max-height:220px;overflow:auto}
  .log{white-space:pre-wrap;max-height:200px;overflow:auto;font-size:12px;color:#cbe}
  a{color:var(--accent)}
</style>
</head>
<body>
  <div class="frame">
    <h1>Scan Muka — Fullset</h1>
    <div class="layout">
      <div class="left">
        <div class="video-wrap">
          <video id="video" autoplay playsinline muted></video>
          <canvas id="overlay"></canvas>
        </div>

        <div class="instr" id="mainInstruction">Instruksi: Tekan <strong>Mulai Scan</strong></div>

        <div class="controls">
          <button id="startBtn">Mulai Scan</button>
          <button id="stopBtn" style="display:none">Stop</button>
          <button id="chooseFolderBtn">Pilih Folder Simpan (opsional)</button>
        </div>

        <div class="small" id="statusLine">Status: idle</div>
      </div>

      <aside class="right">
        <div class="debug">
          <div><strong>Loader:</strong> <span id="loaderStatus">idle</span></div>
          <div><strong>Model:</strong> <span id="modelStatus">waiting</span></div>
          <div><strong>Face:</strong> <span id="faceDetected">no</span></div>
          <div style="margin-top:6px"><strong>Step:</strong> <span id="stepLabel">-</span> (<span id="progress">0/5</span>)</div>
          <hr style="border:none;border-top:1px solid rgba(255,255,255,0.04);margin:8px 0">
          <div><strong>yaw</strong>: <span id="valYaw">-</span></div>
          <div><strong>pitch</strong>: <span id="valPitch">-</span></div>
          <div><strong>EAR</strong>: <span id="valEAR">-</span></div>
          <div><strong>blinkNow</strong>: <span id="valBlink">-</span></div>
          <div><strong>motion</strong>: <span id="valMotion">-</span></div>
          <hr style="border:none;border-top:1px solid rgba(255,255,255,0.04);margin:8px 0">
          <div id="messages" class="small">Messages appear here.</div>
          <div class="log" id="log"></div>
        </div>

        <div class="instr" style="margin-top:10px">
          <strong>Media (preview)</strong>
          <div class="media-list" id="mediaList"></div>
        </div>
      </aside>
    </div>
  </div>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.7.1/dist/jszip.min.js"></script>
<script>
/* ------------------ URLS ------------------ */
const TF_URLS = [
  'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js',
  'https://unpkg.com/@tensorflow/tfjs@3.21.0/dist/tf.min.js'
];

const FLD_ESM_URLS = [
  'https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@1.0.6/dist/face-landmarks-detection.esm.js',
  'https://unpkg.com/@tensorflow-models/face-landmarks-detection@1.0.6/dist/face-landmarks-detection.esm.js'
];

const FLD_UMD_URLS = [
  'https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@1.0.6/dist/face-landmarks-detection.min.js',
  'https://unpkg.com/@tensorflow-models/face-landmarks-detection@1.0.6/dist/face-landmarks-detection.min.js'
];

const MEDIAPIPE_URLS = [
  'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js',
  'https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js',
  'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js',
  'https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js'
];

/* ------------------ DOM helpers ------------------ */
const $ = id => document.getElementById(id);
const logEl = $('log');
function log(...a){ const s = a.map(x => (typeof x==='object' ? JSON.stringify(x) : String(x))).join(' '); logEl.textContent = (new Date()).toISOString() + ' — ' + s + '\n' + logEl.textContent; }

/* ------------------ loaders ------------------ */
function loadScript(url){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=url; s.async=true; s.onload=()=>res(url); s.onerror=(e)=>rej(new Error('script load failed '+url)); document.head.appendChild(s); }); }
async function tryLoadList(urls){
  for(const u of urls){
    try{ await loadScript(u); return u; }catch(e){ log('load failed', u, e.message || e); }
  }
  throw new Error('all failed');
}
async function tryImportList(urls){
  for(const u of urls){
    try{ const mod = await import(u); return {url:u,mod}; }catch(e){ log('import failed', u, e.message || e); }
  }
  throw new Error('all imports failed');
}

/* Ensure libraries available; many fallbacks */
async function ensureLibraries(){
  $('loaderStatus').textContent = 'loading tf...';
  if(!window.tf){
    try{ const tfUrl = await tryLoadList(TF_URLS); log('tf loaded from', tfUrl); }catch(e){ log('tf load failed', e.message||e); }
  } else log('tf already present');

  $('loaderStatus').textContent = 'loading mediapipe libs...';
  for(const url of MEDIAPIPE_URLS){
    try{ await loadScript(url); log('mediapipe script loaded', url); }catch(e){ log('mediapipe script failed', url, e.message||e); }
  }

  $('loaderStatus').textContent = 'loading face-landmarks (esm)...';
  try{
    const r = await tryImportList(FLD_ESM_URLS);
    window._fld_esm = r.mod;
    window.faceLandmarksDetection = r.mod;
    log('face-landmarks (esm) loaded from', r.url);
    $('loaderStatus').textContent = 'esm ok';
    return;
  }catch(e){ log('face-landmarks esm failed', e.message||e); }

  $('loaderStatus').textContent = 'loading face-landmarks (umd)...';
  try{
    const u = await tryLoadList(FLD_UMD_URLS);
    log('face-landmarks UMD exposed on window from', u);
    $('loaderStatus').textContent = 'umd ok';
    return;
  }catch(e){ log('UMD load failed', e.message||e); }

  $('loaderStatus').textContent = 'fetch+eval fallback';
  for(const u of FLD_UMD_URLS){
    try{
      const r = await fetch(u);
      if(!r.ok){ log('fetch failed', u, r.status); continue; }
      const txt = await r.text();
      if(txt.trim().startsWith('<!doctype') || txt.includes('<html')){ log('fetched HTML instead of JS', u); continue; }
      const script = document.createElement('script'); script.text = txt + '\n//# sourceURL=' + u; document.head.appendChild(script);
      if(window.faceLandmarksDetection || window.faceLandmarksDetection?.default){ log('fetch+eval exposed faceLandmarksDetection from', u); $('loaderStatus').textContent = 'eval ok'; return; }
      else log('fetch+eval loaded but global missing', u);
    }catch(e){ log('fetch+eval failed', u, e.message||e); }
  }

  $('loaderStatus').textContent = 'failed';
  $('messages').textContent = 'Gagal memuat library model; Anda bisa meminta saya buatkan versi embed yang menyertakan bundle library di dalam HTML.';
}

/* Warm libraries on load */
ensureLibraries();

/* ------------------ resilient model loader (fullset) ------------------ */
function resolveFldModule(){
  if(window.faceLandmarksDetection) return window.faceLandmarksDetection;
  if(window._fld_esm) return window._fld_esm;
  if(window.faceLandmarksDetection && window.faceLandmarksDetection.default) return window.faceLandmarksDetection.default;
  return null;
}

async function loadModel(){
  $('modelStatus').textContent = 'loading';
  const fld = resolveFldModule();
  if(!fld){
    $('modelStatus').textContent = 'missing';
    $('messages').textContent = 'Model library belum tersedia — cek log.';
    log('loadModel aborted: faceLandmarksDetection missing');
    return false;
  }

  try { log('faceLandmarksDetection keys:', Object.keys(fld || {}).join(', ')); } catch(e){}

  // SupportedPackages discovery
  const SupportedPackages = fld.SupportedPackages ?? fld.default?.SupportedPackages ?? null;

  // Strategy A: fld.load(...)
  try{
    if(typeof fld.load === 'function'){
      const pkg = SupportedPackages?.mediapipeFacemesh ?? SupportedPackages;
      log('Attempting fld.load(...)');
      const m = await fld.load(pkg, { maxFaces: 1 });
      window._faceModel = m;
      $('modelStatus').textContent = 'ready';
      log('Model loaded via fld.load');
      return true;
    }
  }catch(e){ log('fld.load failed', e && e.message ? e.message : e); }

  // Strategy B: fld.default.load(...)
  try{
    if(fld.default && typeof fld.default.load === 'function'){
      log('Attempting fld.default.load(...)');
      const pkg = fld.default.SupportedPackages?.mediapipeFacemesh ?? fld.default.SupportedPackages;
      const m = await fld.default.load(pkg, { maxFaces: 1 });
      window._faceModel = m;
      $('modelStatus').textContent = 'ready';
      log('Model loaded via fld.default.load');
      return true;
    }
  }catch(e){ log('fld.default.load failed', e && e.message ? e.message : e); }

  // Strategy C: createDetector
  try{
    if(typeof fld.createDetector === 'function'){
      log('Attempting fld.createDetector(...)');
      const optsList = [
        { model: 'MediaPipeFaceMesh', runtime: 'tfjs' },
        { runtime: 'tfjs' },
        {}
      ];
      for(const opts of optsList){
        try{
          const detector = await fld.createDetector(opts);
          if(detector && typeof detector.estimateFaces === 'function'){
            window._faceModel = detector;
            $('modelStatus').textContent = 'ready';
            log('Model created via createDetector with opts', opts);
            return true;
          }
        }catch(inner){ log('createDetector attempt failed for opts', opts, inner && inner.message ? inner.message : inner); }
      }
    }
  }catch(e){ log('fld.createDetector failed', e && e.message ? e.message : e); }

  // Strategy D: try common global factories
  try{
    if(fld.FaceMesh && typeof fld.FaceMesh === 'function'){
      log('Detected fld.FaceMesh constructor — attempting instantiate');
      try{
        const inst = new fld.FaceMesh({ locateFile: (f)=>f });
        if(typeof inst.send === 'function' || typeof inst.estimate === 'function'){
          window._faceModel = inst;
          $('modelStatus').textContent = 'ready';
          log('Model instantiated via fld.FaceMesh');
          return true;
        }
      }catch(e){ log('fld.FaceMesh instantiation failed', e && e.message ? e.message : e); }
    }
    if(fld.FaceLandmarksDetector && typeof fld.FaceLandmarksDetector.create === 'function'){
      log('Detected fld.FaceLandmarksDetector.create — attempting create');
      try{
        const det = await fld.FaceLandmarksDetector.create();
        if(det && typeof det.estimateFaces === 'function'){ window._faceModel = det; $('modelStatus').textContent = 'ready'; log('Model created via FaceLandmarksDetector.create'); return true; }
      }catch(e){ log('FaceLandmarksDetector.create failed', e && e.message ? e.message : e); }
    }
  }catch(e){ log('Alternate factory attempts failed', e && e.message ? e.message : e); }

  // Strategy E: scan window for candidate modules
  try{
    const keys = Object.keys(window).filter(k => k.toLowerCase().includes('landmark') || k.toLowerCase().includes('faceland') || k.toLowerCase().includes('face'));
    log('Scanning globals for candidate modules: ' + keys.slice(0,20).join(', '));
    for(const k of keys){
      const cand = window[k];
      if(cand && typeof cand.load === 'function'){
        try{
          log('Attempting to load using global window.'+k+'.load');
          const m = await cand.load(cand.SupportedPackages?.mediapipeFacemesh ?? cand.SupportedPackages, { maxFaces: 1 });
          if(m){ window._faceModel = m; $('modelStatus').textContent = 'ready'; log('Loaded via window.'+k+'.load'); return true; }
        }catch(err){ log('window.'+k+'.load failed', err && err.message ? err.message : err); }
      }
      if(cand && typeof cand.createDetector === 'function'){
        try{
          const d = await cand.createDetector({ runtime:'tfjs' });
          if(d && typeof d.estimateFaces === 'function'){ window._faceModel = d; $('modelStatus').textContent = 'ready'; log('Created detector via window.'+k+'.createDetector'); return true; }
        }catch(err){ log('window.'+k+'.createDetector failed', err && err.message ? err.message : err); }
      }
    }
  }catch(e){ log('Global scan failed', e && e.message ? e.message : e); }

  $('modelStatus').textContent = 'failed';
  $('messages').textContent = 'Gagal memuat model: load function not found on faceLandmarksDetection module';
  log('All model load strategies failed — please embed official UMD bundle or provide module with load/createDetector API.');
  return false;
}

/* ------------------ Liveness / capture ------------------ */
let streamRef = null;
let recorder = null;
let recordedBlobs = [];
let frameBlobs = [];
let captureInterval = null;
let detectLoopActive = false;
let folderHandle = null;
let lastFrameData = null;

/* helpers */
function addMediaItem(name, blob){ const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; a.textContent=name; $('mediaList').prepend(a); }
function clearCanvas(){ const c=$('overlay'); c.getContext('2d').clearRect(0,0,c.width,c.height); }
function averagePoint(idxs, landmarks){ let x=0,y=0,c=0; for(const i of idxs){ if(!landmarks[i]) continue; x+=landmarks[i][0]; y+=landmarks[i][1]; c++; } return [x/c,y/c]; }
function computeEAR(upper, lower){ const v=(Math.hypot(upper[1][0]-lower[5][0], upper[1][1]-lower[5][1]) + Math.hypot(upper[2][0]-lower[4][0], upper[2][1]-lower[4][1]))/2; const h=Math.hypot(upper[0][0]-upper[3][0], upper[0][1]-upper[3][1])||1; return v/h; }
function estimateYaw(landmarks){ const left=averagePoint([33,133,159,158],landmarks); const right=averagePoint([362,263,386,387],landmarks); const nose=landmarks[1]||[(left[0]+right[0])/2,(left[1]+right[1])/2]; const dxL=nose[0]-left[0]; const dxR=right[0]-nose[0]; return (dxL-dxR)*0.5; }
function estimatePitch(landmarks){ const nose=landmarks[1]||[0,0]; const eyeCenter=averagePoint([33,133,362,263],landmarks); return (eyeCenter[1]-nose[1]); }

/* folder picker */
$('chooseFolderBtn').addEventListener('click', async ()=>{ if('showDirectoryPicker' in window){ try{ folderHandle = await window.showDirectoryPicker(); $('messages').textContent='Folder terpilih.'; }catch(e){ $('messages').textContent='Pemilihan folder dibatalkan.'; } } else $('messages').textContent='Browser tidak mendukung penyimpanan lokal otomatis. ZIP fallback akan digunakan.'; });

/* start camera & record */
async function startCameraAndRecord(){
  try{
    const s = await navigator.mediaDevices.getUserMedia({video:{width:640,height:480,facingMode:'user'}, audio:true});
    $('video').srcObject = s;
    streamRef = s;
    await $('video').play();
    const c = $('overlay'); c.width = $('video').videoWidth || 640; c.height = $('video').videoHeight || 480;
    recordedBlobs = []; frameBlobs = []; lastFrameData = null;
    try{ recorder = new MediaRecorder(streamRef, {mimeType:'video/webm;codecs=vp9,opus'}); }catch(e){ recorder = new MediaRecorder(streamRef); }
    recorder.ondataavailable = ev => { if(ev.data && ev.data.size) recordedBlobs.push(ev.data); };
    recorder.start();
    const capCanvas = document.createElement('canvas'); capCanvas.width = c.width; capCanvas.height = c.height;
    const capCtx = capCanvas.getContext('2d');
    captureInterval = setInterval(()=>{ capCtx.drawImage($('video'),0,0,capCanvas.width,capCanvas.height); capCanvas.toBlob(b=>{ const ts=Date.now(); const name=`frame_${ts}.png`; frameBlobs.push({blob:b,name}); addMediaItem(name,b); }, 'image/png'); }, 1000);
    return true;
  }catch(e){
    $('messages').textContent = 'Gagal akses kamera: '+(e.message||e);
    log('camera error', e);
    return false;
  }
}

/* steps */
const STEPS = [
  { id:'center', label:'Hadapkan muka ke tengah', validator: c=> Math.abs(c.avgYaw) < 8 && Math.abs(c.avgPitch) < 10, need: 3 },
  { id:'left', label:'Miring ke KIRI', validator: c=> c.avgYaw < -12, need: 3 },
  { id:'right', label:'Miring ke KANAN', validator: c=> c.avgYaw > 12, need: 3 },
  { id:'blink', label:'Kedipkan mata', validator: c=> c.blinkNow === true, need: 1 },
  { id:'nod', label:'Angguk kepala', validator: c=> Math.abs(c.avgPitch) > 12, need: 3 }
];
let currentStepIndex = 0;
let yawBuf = [], pitchBuf = [], earBuf = [], lastBlinkTs = 0, consecutive = {};
const MAX_TIME = 120;
let detectLoopActive = false;

async function detectLoop(){
  detectLoopActive = true;
  const startTime = Date.now();
  const v = $('video'); const c = $('overlay'); const ctx = c.getContext('2d');
  STEPS.forEach(s=>consecutive[s.id]=0);
  $('stepLabel').textContent = STEPS[currentStepIndex].label;
  $('progress').textContent = `0/${STEPS.length}`;
  $('statusLine').textContent = 'Scanning...';

  while(detectLoopActive){
    const modelInst = window._faceModel;
    if(!modelInst){ await new Promise(r=>setTimeout(r,200)); continue; }
    try{
      // modelInst may be detector or returned API from fld.load
      const preds = await modelInst.estimateFaces({ input: v, returnTensors:false, flipHorizontal:true }).catch(async (e)=>{
        // some detectors use slightly different signature (e.g. detector.estimateFaces(input))
        try { return await modelInst.estimateFaces(v); } catch(err){ throw err; }
      });
      ctx.clearRect(0,0,c.width,c.height);

      if(preds && preds.length>0){
        const lm = preds[0].scaledMesh || preds[0].keypoints || preds[0].landmarks || preds[0].positions;
        // normalize landmarks shape if necessary — prefer scaledMesh
        const landmarks = preds[0].scaledMesh ? preds[0].scaledMesh : (preds[0].keypoints ? preds[0].keypoints.map(k=>[k.x,k.y]) : (preds[0].landmarks ? preds[0].landmarks : (preds[0].positions ? preds[0].positions : [])));
        // draw
        ctx.fillStyle='rgba(6,182,212,0.9)';
        for(let i=0;i<landmarks.length;i+=12){ ctx.beginPath(); ctx.arc(landmarks[i][0], landmarks[i][1], 1.2,0,Math.PI*2); ctx.fill(); }
        $('faceDetected').textContent='yes';

        const Y = estimateYaw(landmarks);
        const P = estimatePitch(landmarks);
        yawBuf.push(Y); if(yawBuf.length>6) yawBuf.shift();
        pitchBuf.push(P); if(pitchBuf.length>6) pitchBuf.shift();

        const leftUpper=[landmarks[159],landmarks[160],landmarks[158],landmarks[33]];
        const leftLower=[landmarks[145],landmarks[144],landmarks[153],landmarks[133]];
        const rightUpper=[landmarks[386],landmarks[387],landmarks[385],landmarks[362]];
        const rightLower=[landmarks[374],landmarks[373],landmarks[380],landmarks[263]];
        const earL = computeEAR(leftUpper,leftLower);
        const earR = computeEAR(rightUpper,rightLower);
        const ear = (earL+earR)/2;
        earBuf.push(ear); if(earBuf.length>10) earBuf.shift();

        let blinkNow = false;
        if(earBuf.length>=3){
          const a=earBuf[earBuf.length-3], b=earBuf[earBuf.length-2], cval=earBuf[earBuf.length-1];
          if(b < 0.18 && cval >= 0.18 && (Date.now()-lastBlinkTs) > 400){ blinkNow=true; lastBlinkTs = Date.now(); }
        }

        // motion
        const tmp = document.createElement('canvas'); tmp.width=c.width; tmp.height=c.height;
        const tctx = tmp.getContext('2d'); tctx.drawImage(v,0,0,tmp.width,tmp.height);
        const idata = tctx.getImageData(0,0,tmp.width,tmp.height);
        let motion = 0;
        if(!lastFrameData){ lastFrameData = idata; motion = 0; } else {
          let diff = 0; for(let i=0;i<idata.data.length;i+=4){ diff += Math.abs(idata.data[i]-lastFrameData.data[i]); diff += Math.abs(idata.data[i+1]-lastFrameData.data[i+1]); diff += Math.abs(idata.data[i+2]-lastFrameData.data[i+2]); }
          motion = diff / (idata.data.length/4); lastFrameData = idata;
        }

        const avgYaw = yawBuf.reduce((a,b)=>a+b,0)/yawBuf.length;
        const avgPitch = pitchBuf.reduce((a,b)=>a+b,0)/pitchBuf.length;
        $('valYaw').textContent = avgYaw.toFixed(2);
        $('valPitch').textContent = avgPitch.toFixed(2);
        $('valEAR').textContent = ear.toFixed(3);
        $('valBlink').textContent = blinkNow ? 'yes' : 'no';
        $('valMotion').textContent = motion.toFixed(1);

        const step = STEPS[currentStepIndex];
        const ctxObj = { avgYaw, avgPitch, ear, earBuf, blinkNow, motion };
        const ok = step.validator(ctxObj);
        if(step.id !== 'blink'){
          if(ok) consecutive[step.id] = Math.min(step.need, consecutive[step.id] + 1);
          else consecutive[step.id] = 0;
          $('mainInstruction').textContent = `${step.label} (${consecutive[step.id]}/${step.need})`;
        } else {
          if(ok) consecutive[step.id] = 1;
          $('mainInstruction').textContent = `${step.label} (${consecutive[step.id]}/${step.need})`;
        }

        if(consecutive[step.id] >= step.need){
          $('mainInstruction').textContent = `${step.label} — OK`;
          currentStepIndex++;
          $('progress').textContent = `${currentStepIndex}/${STEPS.length}`;
          if(currentStepIndex < STEPS.length){
            $('stepLabel').textContent = STEPS[currentStepIndex].label;
            $('mainInstruction').textContent = `Berhasil: lanjut → ${STEPS[currentStepIndex].label}`;
            yawBuf=[]; pitchBuf=[]; earBuf=[]; Object.keys(consecutive).forEach(k=>consecutive[k]=0);
            await new Promise(r=>setTimeout(r,500));
          } else {
            if(motion > 8){ detectLoopActive=false; await finish(true); return; }
            else { $('mainInstruction').textContent='Gerakkan kepala sedikit untuk verifikasi akhir'; await new Promise(r=>setTimeout(r,800)); if(lastFrameData && motion>8){ detectLoopActive=false; await finish(true); return; } else { detectLoopActive=false; await finish(false); return; } }
          }
        }

      } else {
        $('faceDetected').textContent='no';
        $('mainInstruction').textContent = STEPS[currentStepIndex].label;
      }
    }catch(e){
      log('detectLoop error', e && e.message ? e.message : e);
    }

    const elapsed = Math.floor((Date.now() - startTime)/1000);
    if(elapsed >= MAX_TIME){ detectLoopActive=false; await finish(false); return; }
    await new Promise(r=>setTimeout(r,120));
  }
}

/* finish/save */
async function finish(success){
  $('statusLine').textContent = success ? 'Verifikasi: BERHASIL' : 'Verifikasi: GAGAL';
  clearInterval(captureInterval);
  if(recorder && recorder.state !== 'inactive'){ try{ recorder.stop(); }catch(e){} }
  if(streamRef){ streamRef.getTracks().forEach(t=>t.stop()); streamRef=null; }

  const videoBlob = new Blob(recordedBlobs, {type: recordedBlobs[0]?.type || 'video/webm'});
  addMediaItem(`scan_result_${Date.now()}.webm`, videoBlob);

  const manifest = { result: success ? 'success' : 'failed', ts: Date.now(), frames_count: frameBlobs.length, video_size: videoBlob.size };

  if(folderHandle && 'getDirectoryHandle' in folderHandle){
    try{
      const framesDir = await folderHandle.getDirectoryHandle('frames', {create:true});
      const vHandle = await folderHandle.getFileHandle(`scan_result_${manifest.ts}.webm`, {create:true});
      const wv = await vHandle.createWritable(); await wv.write(videoBlob); await wv.close();
      for(const f of frameBlobs){
        const fh = await framesDir.getFileHandle(f.name, {create:true});
        const wf = await fh.createWritable(); await wf.write(f.blob); await wf.close();
      }
      const mf = await folderHandle.getFileHandle(`manifest_${manifest.ts}.json`, {create:true});
      const wm = await mf.createWritable(); await wm.write(JSON.stringify(manifest,null,2)); await wm.close();
      $('messages').textContent = `Tersimpan ke folder lokal (${success ? 'success' : 'failed'}).`;
    }catch(e){
      log('save to folder failed', e && e.message ? e.message : e);
      await saveAsZip(videoBlob, frameBlobs, manifest);
    }
  } else {
    await saveAsZip(videoBlob, frameBlobs, manifest);
  }

  if(success) setTimeout(()=> window.location.href = `result.html?result=success&ts=${manifest.ts}`, 700);
  else { $('statusLine').textContent='Gagal — Tekan Mulai Scan untuk ulang.'; $('startBtn').style.display='inline-block'; $('stopBtn').style.display='none'; }
}

async function saveAsZip(videoBlob, frames, manifest){
  const zip = new JSZip();
  if(videoBlob && videoBlob.size>0) zip.file(`scan_result_${manifest.ts}.webm`, videoBlob);
  const fdir = zip.folder('frames');
  for(const f of frames) fdir.file(f.name, f.blob);
  zip.file(`manifest_${manifest.ts}.json`, JSON.stringify(manifest,null,2));
  const content = await zip.generateAsync({type:'blob'});
  const url = URL.createObjectURL(content);
  const a = document.createElement('a'); a.href = url; a.download = `scan_media_${manifest.ts}.zip`; a.click();
  URL.revokeObjectURL(url);
  $('messages').textContent = 'Hasil disimpan sebagai ZIP (fallback).';
}

/* UI handlers */
$('startBtn').addEventListener('click', async ()=>{
  $('startBtn').style.display='none'; $('stopBtn').style.display='inline-block';
  $('statusLine').textContent='Memulai...';
  await ensureLibraries();
  const ok = await loadModel();
  if(!ok){ $('statusLine').textContent='Model tidak tersedia'; $('startBtn').style.display='inline-block'; $('stopBtn').style.display='none'; return; }
  const camOk = await startCameraAndRecord();
  if(!camOk){ $('statusLine').textContent='Tidak dapat akses kamera'; $('startBtn').style.display='inline-block'; $('stopBtn').style.display='none'; return; }
  detectLoop();
});

$('stopBtn').addEventListener('click', ()=>{
  detectLoopActive=false;
  if(captureInterval) clearInterval(captureInterval);
  if(recorder && recorder.state !== 'inactive'){ try{ recorder.stop(); }catch(e){} }
  if(streamRef){ streamRef.getTracks().forEach(t=>t.stop()); streamRef=null; }
  $('startBtn').style.display='inline-block'; $('stopBtn').style.display='none';
  $('statusLine').textContent='Dihentikan.';
});

/* cleanup */
window.addEventListener('beforeunload', ()=>{ if(streamRef) streamRef.getTracks().forEach(t=>t.stop()); });
</script>
</body>
</html>